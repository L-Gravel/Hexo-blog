<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cn" lang="cn">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.49" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>【转载】java.lang.String &middot; Gravel</title>

  
  <link type="text/css" rel="stylesheet" href="https://leongravel.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://leongravel.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://leongravel.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://leongravel.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Gravel" />

  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://leongravel.com/"><h1>Gravel</h1></a>
      <p class="lead">
       A Empty-Stack Developer.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://leongravel.com/">Home</a> </li>
        <li><a href="/posts/"> Posts </a></li><li><a href="/portfolio/"> Portfolio </a></li><li><a href="/about/about"> About </a></li>
      </ul>
    </nav>

    <p>&copy; 2018. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>【转载】java.lang.String</h1>
  <time datetime=2018-03-12T20:54:41Z class="post-date">Mon, Mar 12, 2018</time>
  

<p>整理一下关于String类的方法。</p>

<!-- more -->

<hr />

<!-- TOC -->

<ul>
<li><a href="#概览">概览</a></li>
<li><a href="#继承结构">继承结构</a>

<ul>
<li><a href="#serializable">Serializable</a></li>
<li><a href="#charsequence">CharSequence</a></li>
<li><a href="#comparablet">Comparable<T></a></li>
</ul></li>
<li><a href="#字符集简介">字符集简介</a></li>
<li><a href="#重要域成员">重要域成员</a></li>
<li><a href="#重要方法">重要方法</a>

<ul>
<li><a href="#代码点及代码单元">代码点及代码单元</a></li>
<li><a href="#比较">比较</a></li>
<li><a href="#搜索">搜索</a></li>
<li><a href="#提取子串">提取子串</a></li>
<li><a href="#创建全大写全小写副本">创建全大写/全小写副本</a></li>
</ul></li>
<li><a href="#一些体会">一些体会</a></li>
<li><a href="#参考">参考</a></li>
</ul>

<!-- /TOC -->

<hr />

<h2 id="概览">概览</h2>

<p><code>String</code> 类代表了字符串。所有类似于 <code>&quot;abc&quot;</code> 的字符串字面量都是该类的实例。</p>

<p>字符串是常量，从创建后就不可更改。需要修改的字符串可以使用 <code>StringBuffer</code>。因为 <code>String</code> 实例不可变，所以他们可以安全的共享。一些例子：</p>

<pre><code class="language-java">String str = &quot;abc&quot;;
// 与上面一行代码效果相同
char data[] = {'a', 'b', 'c'};
String str = new String(data);


System.out.println(&quot;abc&quot;);
String cde = &quot;cde&quot;;
System.out.println(&quot;abc&quot; + cde);
String c = &quot;abc&quot;.substring(2,3);
String d = cde.substring(1, 2);
</code></pre>

<p><code>String</code> 类也包含了一些对单个字符的操作、比较、搜索、提取子串、创建全大写/全小写副本的方法。</p>

<p>Java 语言为字符串连接操作符(+)添加了特殊支持。向左连接。</p>

<pre><code class="language-java">//  example 1
&quot;The square root of 2 is &quot; + Math.sqrt(2)
  |
  v
&quot;The square root of 2 is 1.4142135623730952&quot;

// example 2
1 + 2 + &quot; fiddlers&quot;
  |
  v
&quot;3 fiddlers&quot;

// example 3
&quot;fiddlers &quot; + 1 + 2
  |
  v
&quot;fiddlers 12&quot;

</code></pre>

<p><code>String</code> 使用 UTF-16 来编码（一个字符两个字节或四个字节）。拓展字符用 surrogate pairs 来表示，占用四个字节。（PS：该术语是编码领域的，可以参考之前写的一篇笔记: <a href="../common/unicodeStandard.md">Unicode 学习笔记</a>）</p>

<p><code>String</code> 也提供了一些处理代码点(Unicode code points)和代码单元(Unicode code units)的方法(PS:这两个也是编码领域术语，可以参考：<a href="../common/unicodeStandard.md">Unicode 学习笔记</a>)。</p>

<p>String 连接操作符的具体实现留给 Java 编译器来决定，只要编译器能够完全遵循 Java 语言规范即可。例如 <code>javac</code> 编译器可能用 <code>StringBuffer</code>、<code>StringBuilder</code> 或 <code>java.lang.invoke.StringCOncatFactory</code> 来实现。</p>

<h2 id="继承结构">继承结构</h2>

<h3 id="serializable">Serializable</h3>

<p>类通过实现 <code>java.io.Serializable</code> 接口来启用序列化能力。未实现该接口的类其状态将不会被序列化(抛出 <code>NotSerializableException</code> 异常)。该接口没有任何域或方法，只是表示可序列化的语义。</p>

<pre><code class="language-java">    public static void serializableTest() throws IOException, ClassNotFoundException {
        String outputfile = &quot;/Users/chen/Desktop/serializable&quot;;
        ST instance = new ST();

        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(outputfile));
        outputStream.writeObject(instance);
        outputStream.close();

        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(outputfile));
        ST newInstance = (ST) inputStream.readObject();
        inputStream.close();

        System.out.println(newInstance);
        System.out.println(instance.equals(newInstance));  // true
        System.out.println(instance == newInstance); //false
    }

    static class ST implements Serializable{
        public int publicField = 1;
        protected int protectedField = 1;
        int defaultField = 1;
        private int privateField = 1;

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            ST st = (ST) o;
            return publicField == st.publicField &amp;&amp;
                    protectedField == st.protectedField &amp;&amp;
                    defaultField == st.defaultField &amp;&amp;
                    privateField == st.privateField;
        }

        @Override
        public int hashCode() {
            return Objects.hash(publicField, protectedField, defaultField, privateField);
        }

        @Override
        public String toString() {
            return &quot;ST{&quot; +
                    &quot;publicField=&quot; + publicField +
                    &quot;, protectedField=&quot; + protectedField +
                    &quot;, defaultField=&quot; + defaultField +
                    &quot;, privateField=&quot; + privateField +
                    '}';
        }
    }
</code></pre>

<p>序列化的对象中引用的所有对象都必须实现了该接口，否则也会抛出 <code>NotSerializableException</code> 异常。</p>

<h3 id="charsequence">CharSequence</h3>

<p>一个 <code>CharSequence</code> 是一个只读的 <code>char</code> 序列。该接口为不同的实现提供了统一的只读访问。</p>

<p>该接口并没有重新定义 <code>equals() &amp; hashCode()</code> 方法，直接比较两个实现类的实例结果是未定义的。所以将 <code>CharSequence</code> 的实例作为 <code>set</code> 的元素或 <code>map</code> 的 <code>key</code> 是不合适的。</p>

<p>主要的实现类：<code>CharBuffer, Segment, String, StringBuffer, StringBuilder</code></p>

<p><code>String</code> 中也实现了与 <code>CharSequence</code> 实例进行比较、拼接等操作的函数。</p>

<h3 id="comparable-t">Comparable<T></h3>

<p>主要用于集合中元素排序，两个元素直接比较。</p>

<h2 id="字符集简介">字符集简介</h2>

<p><code>String</code> 类中用到了两种字符集 <code>Latin1 &amp; UTF-16</code>. <code>Latin1</code> 拓展了 <code>ASCII</code> 编码，但是也是用一个字节来表示，<code>UTF-16</code> 使用两个或四个字节表示一个字符。简要介绍请看：<a href="../common/unicodeStandard.md">Unicode 学习笔记</a></p>

<pre><code class="language-java">/**
    在构造一个 String 对象时，String 会尝试对传入的参数进行压缩。比如

    String latin1 = new String(&quot;latin1&quot;.toCharArray());
    String utf16 = new String(&quot;使用 UTF-16 字符集&quot;.toCharArray());

    入参是 char[]，java 中 char 是两个字节，byte 是一个字节，压缩后 latin1 的 value 字段是 6 个 byte，utf16 无法进行压缩，所以依旧是 26 个 byte。

    下面是 java.lang.StringUTF16 中进行压缩的函数。
 */
    // compressedCopy char[] -&gt; byte[]
    @HotSpotIntrinsicCandidate
    public static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {
        for (int i = 0; i &lt; len; i++) {
            char c = src[srcOff];
            if (c &gt; 0xFF) {     // 超出了 LATIN1 所能表示的范围，直接返回不再压缩
                len = 0;
                break;
            }
            dst[dstOff] = (byte)c;
            srcOff++;
            dstOff++;
        }
        return len;
    }
</code></pre>

<h2 id="重要域成员">重要域成员</h2>

<ol>
<li><code>private final byte[] value;</code>

<ul>
<li>用来存储字符串的字节序列。</li>
</ul></li>
<li><code>private final byte coder;</code>

<ul>
<li>用来暗示 <code>value</code> 中的字节数组的编码方式。有 <code>LATIN1 &amp; UTF16</code> 可选。</li>
<li><code>static final byte LATIN1 = 0;</code></li>
<li><code>static final byte UTF16  = 1;</code></li>
</ul></li>
<li><code>private int hash;</code>

<ul>
<li>缓存字符串哈希值。默认是 0. 在 首次调用 <code>hashCode()</code> 方法时计算并缓存。</li>
</ul></li>
<li><code>static final boolean COMPACT_STRINGS;</code>

<ul>
<li>用来决定 <code>value</code> 是否进行压缩，默认是 true（压缩）。如果是 false 的话那么总是使用 UTF16 来编码字符串的字节流。在 <code>String</code> 类中，该域使用静态初始化块进行初始化。</li>
</ul></li>
</ol>

<h2 id="重要方法">重要方法</h2>

<ul>
<li>TIPS：本来计划中有这部分的内容，但是读过源码理解了字符集的概念和 <code>String</code> 的处理方式以后感觉这部分就不需要再写了，有兴趣可以自己看。</li>
</ul>

<h3 id="代码点及代码单元">代码点及代码单元</h3>

<h3 id="比较">比较</h3>

<h3 id="搜索">搜索</h3>

<h3 id="提取子串">提取子串</h3>

<h3 id="创建全大写-全小写副本">创建全大写/全小写副本</h3>

<h2 id="一些体会">一些体会</h2>

<p>理解 <code>String</code> 类最重要的不是会用 <code>String</code> 的 API，而是对字符集本身的理解，字符集是什么，它解决了什么问题，字符是怎么编码的等等，只有很好的理解了字符集才能很好的理解 <code>String</code> 的行为。</p>

<h2 id="参考">参考</h2>

<ol>
<li><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html">java.lang.String</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-15.html#jls-15.18.1">15.18.1. String Concatenation Operator +</a></li>
<li><a href="https://docs.oracle.com/javase/9/docs/api/java/io/Serializable.html">Serializable</a></li>
<li><a href="http://www.cnblogs.com/chenfei0801/archive/2013/04/05/3001149.html">JAVA 对象序列化（一）——Serializable</a></li>
<li><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html">CharSequence</a></li>
<li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO/IEC 8859-1</a></li>
</ol>

</div>

<h2>Comments</h2>
<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "leongravel" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </main>

    
  </body>
</html>
