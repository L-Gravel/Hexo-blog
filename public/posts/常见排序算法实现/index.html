<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cn" lang="cn">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.49" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>常见排序算法实现 &middot; Gravel</title>

  
  <link type="text/css" rel="stylesheet" href="https://leongravel.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://leongravel.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://leongravel.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://leongravel.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Gravel" />

  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://leongravel.com/"><h1>Gravel</h1></a>
      <p class="lead">
       A Empty-Stack Developer.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://leongravel.com/">Home</a> </li>
        <li><a href="/posts/"> Posts </a></li><li><a href="/portfolio/"> Portfolio </a></li><li><a href="/about/about"> About </a></li>
      </ul>
    </nav>

    <p>&copy; 2018. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>常见排序算法实现</h1>
  <time datetime=2018-04-15T20:54:41Z class="post-date">Sun, Apr 15, 2018</time>
  <p>整理一下比较常见的几种排序算法</p>

<p></p>

<pre><code class="language-java">package com.gravel.sort;


import java.util.Arrays;
import java.util.Random;

/**
 * Created by chen on 4/14/17.
 */
public class Sort {
    private static final int SIZE = 50;
    private static int[] array = new int[SIZE];

    public static void init() {
        Random random = new Random();
        for (int i = 0; i &lt; SIZE; ++i) {
            array[i] = random.nextInt(100);
        }
    }

    private static void swap(int index1, int index2) {
        int temp = array[index1];
        array[index1] = array[index2];
        array[index2] = temp;
    }

    /**
     * 冒泡排序
     * &lt;p&gt;
     * 下标小于 i 的元素都是已排好序的，内层 for 循环使小元素一步一步交换到前面
     * &lt;p&gt;
     * &lt;p&gt;
     * 时间复杂度：O(n^2)
     * 空间复杂度：O(1)
     *
     * @param array
     */
    public static void bubbleSort(int[] array) {
        if (array == null) {
            throw new IllegalArgumentException(&quot;array can't be null&quot;);
        }
        int len = array.length;
        for (int i = 0; i &lt; len; ++i) {
            for (int j = len - 1; j &gt; i; --j) {
                if (array[j - 1] &gt; array[j]) {
                   swap(j-1,j);
                }
            }
        }
    }

    /**
     * 选择排序
     * &lt;p&gt;
     * 下标小于 i 的元素都是已排好序的，
     * 内层 for 循环寻找 [i,len) 之间最小的元素，
     * 然后将其与 下标为 i 的元素交换位置
     * &lt;p&gt;
     * 时间复杂度：O(n^2)
     * 空间复杂度：O(1)
     *
     * @param array
     */
    public static void selectSort(int[] array) {
        if (array == null) {
            throw new IllegalArgumentException(&quot;array can't be null&quot;);
        }
        int len = array.length;
        for (int i = 0; i &lt; len; ++i) {
            int index = i;
            for (int j = i + 1; j &lt; len; ++j) {
                if (array[index] &gt; array[j]) {
                    index = j;
                }
            }
            if (index != i) {
                swap(index, i);
            }
        }
    }

    /**
     * 插入排序
     * &lt;p&gt;
     * 下标小于 i 的元素都是已排好序的，
     * 内层 while 循环寻找元素 i 适合插入的位置，并将大于 array[i] 的元素后移
     * &lt;p&gt;
     * 时间复杂度：O(n^2)
     * 空间复杂度：O(1)
     *
     * @param array
     */
    public static void insertSort(int[] array) {
        if (array == null) {
            throw new IllegalArgumentException(&quot;array can't be null&quot;);
        }
        int len = array.length;
        for (int i = 1; i &lt; len; ++i) {
            int j = i - 1;
            int temp = array[i];
            while (j &gt; -1 &amp;&amp; temp &lt; array[j]) {
                array[j + 1] = array[j];
                --j;
            }
            array[j + 1] = temp;
        }
    }

    /**
     *
     * 快排
     *
     * 选取最左侧的元素作为枢轴
     *
     * 时间复杂度：O(nlogn)
     * 空间复杂度：O(logn)
     *
     * @param array
     */
    public static void quickSort(int[] array) {
        if (array == null) {
            throw new IllegalArgumentException(&quot;array can't be null&quot;);
        }

        quickSort(array, 0, array.length - 1);
    }

    private static void quickSort(int[] array, int left, int right) {
        if (left &lt; right) {
            int mid = partition(array, left, right);
            quickSort(array, left, mid - 1);
            quickSort(array, mid + 1, right);
        }
    }

    /**
     * 进行分区，返回枢轴所在下标。枢轴的左侧元素均比枢轴小，右侧元素均比枢轴大。
     *
     * @param array
     * @param left
     * @param right
     * @return
     */
    private static int partition(int[] array, int left, int right) {
        int leftIndex = left;    // 左游标
        int rightIndex = right;  // 右游标
        int pivot;               // 枢轴下标

        int midVal = array[leftIndex];
        leftIndex++;
        while (true) {
            while (leftIndex &lt; rightIndex &amp;&amp; midVal &gt;= array[leftIndex]) {
                ++leftIndex;
            }
            while (leftIndex &lt; rightIndex &amp;&amp; midVal &lt;= array[rightIndex]) {
                --rightIndex;
            }

            if (leftIndex &lt; rightIndex) {
                swap(leftIndex, rightIndex);
            } else {
                if (midVal &gt; array[leftIndex]) {
                    swap(left, leftIndex);
                    pivot = leftIndex;
                } else {
                    swap(left, leftIndex - 1);
                    pivot = leftIndex - 1;
                }
                break;
            }
        }
        return pivot;
    }



    /**
     * 归并排序
     * &lt;p&gt;
     * 使用递归的方式实现，比较简洁，已理解。
     * &lt;p&gt;
     * 时间复杂度：O(nlogn)
     * 空间复杂度：O(n)
     *
     * @param array
     */
    public static void mergeSort(int[] array) {
        if (array == null) {
            throw new IllegalArgumentException(&quot;array can't be null&quot;);
        }
        int[] temp = new int[SIZE];
        mergeSort(array, temp, 0, array.length - 1);
    }

    private static void mergeSort(int[] array, int[] temp, int begin, int end) {
        if (begin &lt; end) {
            int mid = (begin + end) / 2;
//            System.out.print(&quot;begin: &quot; + begin + &quot; end: &quot; + end);
//            System.out.println(&quot;     [&quot; + begin +&quot;, &quot; + mid + &quot;], [&quot; + (mid+1) +&quot;,&quot; + end + &quot;]&quot;);
            mergeSort(array, temp, begin, mid);
            mergeSort(array, temp, mid + 1, end);
            merge(array, temp, begin, mid, end);
        }
    }

    /**
     *
     * 合并两个已排好序的数列，两个数列所在范围是 [begin, mid], [mid+1, end]
     *
     * @param array
     * @param temp
     * @param begin
     * @param mid
     * @param end
     */
    private static void merge(int[] array, int[] temp, int begin, int mid, int end) {
        int i = begin;
        int j = mid + 1;
        int k = begin;
        while (i &lt;= mid &amp;&amp; j &lt;= end) {
            if (array[i] &lt;= array[j]) {
                temp[k++] = array[i++];
            } else {
                temp[k++] = array[j++];
            }
        }
        while (j &lt;= end) {
            temp[k++] = array[j++];
        }
        while (i &lt;= mid) {
            temp[k++] = array[i++];
        }
        for (i = begin; i &lt;= end; ++i) {
            array[i] = temp[i];
        }
//        System.out.println(Arrays.toString(array));
    }

    /**
     * 堆排序
     * &lt;p&gt;
     * 基本思路：
     * 1. 构造最大堆
     * 2. 将 array[0] 与 array[length-1] 交换，并将新的 array[0] 下沉恢复 [0,length-1) 的最大堆...一直到 恢复 [0,1) 的最大堆
     *
     * @param array
     */
    public static void heapSort(int[] array) {
        if (array == null) {
            throw new IllegalArgumentException(&quot;array can't be null&quot;);
        }
        // 构造最大堆
        // [array.length/2 , array.length-1] 的元素都是叶子节点，不需要下沉
        for (int i = array.length / 2 - 1, end = array.length - 1; i &gt;= 0; --i) {
            down(array, i, end);
        }

        // 堆排序
        for (int end = array.length - 1; end &gt; 0; ) {
            swap(0, end--);
            down(array, 0, end);
        }
    }

    /**
     *
     * 将数组中下标为 root 的元素进行下沉，终结下标为 end(包含 end)
     *
     * @param array
     * @param root
     * @param end
     */
    private static void down(int[] array, int root, int end) {
        int leaf = 2 * root + 1;
        while (leaf &lt;= end) {
            if (leaf + 1 &lt;= end &amp;&amp; array[leaf] &lt; array[leaf + 1]) {
                leaf++;
            }
            if (array[root] &gt; array[leaf]) {
                break;
            }
            swap(root, leaf);
            root = leaf;
            leaf = 2 * root + 1;
        }
    }


    public static void main(String[] args) {
//        System.out.println(-1 / 2);
        init();
        System.out.println(Arrays.toString(array));
//        bubbleSort(array);
//        selectSort(array);
//        insertSort(array);
        quickSort(array);
//        mergeSort(array);
//        heapSort(array);
        System.out.println(Arrays.toString(array));
    }
}

</code></pre>

<h2 id="参考">参考</h2>

<ol>
<li><a href="http://www.jianshu.com/p/f5baf7f27a7e">各种排序算法总结</a></li>
</ol>
</div>

<h2>Comments</h2>
<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "leongravel" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </main>

    
  </body>
</html>
